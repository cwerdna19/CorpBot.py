""" Template copied from Examples cog. Heavily 'borrowed' from Hw cog."""
import asyncio, discord, random, time
from   discord.ext import commands
from   Cogs import Utils, Settings, DisplayName, UserTime, PickList, Nullify

def setup(bot):
    # Add the bot and deps
    settings = bot.get_cog("Settings")
    bot.add_cog(Tickets(bot, settings))

class Tickets(commands.Cog):

    def __init__(self, bot, settings):
        self.bot = bot
        self.ticketMax = 50
        self.settings = settings
        self.ticketactive = {}
        global Utils, DisplayName
        Utils = self.bot.get_cog("Utils")
        DisplayName = self.bot.get_cog("DisplayName")
        self.tickets = {}
        
    def gen_id(self):
        # Just use the current time as that shouldn't ever be the same (unless a user
        # manages to do this twice in < 1 second)
        return str(time.time())
        
    def checkSuppress(self, ctx):
        if not ctx.guild:
            return False
        if self.settings.getServerStat(ctx.guild, "SuppressMentions"):
            return True
        else:
            return False

    # What was this function going to do?
    def useTickets(self, server):
        return

    @commands.command()
    async def allowtickets(self, ctx, *, allow: str = None):
        if not await Utils.is_admin_reply(ctx): return
        
        if allow == None:
            msg = 'Please include **yes** or **no** in the command to enable or disable tickets in your server.'
        elif allow.lower() == 'yes':
            self.settings.setServerStat(ctx.guild, "UseTickets", True)
            msg = f'Tickets are now enabled. Use {ctx.prefix}newticket to get started.'
        elif allow.lower() == 'no':
            self.settings.setServerStat(ctx.guild, "UseTickets", False)
            msg = 'Tickets are now disabled.'
            
        await ctx.channel.send(msg)
        
    @commands.command(pass_context=True)
    async def setticketchannel(self, ctx, *, channel: discord.TextChannel = None):
        """Sets the channel for Tickets (admin only)."""
        isAdmin = ctx.message.author.permissions_in(ctx.message.channel).administrator
        
        if not isAdmin:
            await ctx.channel.send('You do not have sufficient privileges to access this command.')
            return

        if channel == None:
            self.settings.setServerStat(ctx.guild, "TicketsChannel", "")
            msg = 'Tickets work *only* in pm now.'
            await ctx.channel.send(msg)
            return

        # If we made it this far - then we can add it
        self.settings.setServerStat(ctx.message.guild, "TicketsChannel", channel.id)

        msg = 'Tickets channel set to **{}**.'.format(channel.name)
        await ctx.channel.send(msg)
        
    @setticketchannel.error
    async def setticketchannel_error(self, error, ctx):
        # do stuff
        msg = 'setticketchannel Error: {}'.format(error)
        await ctx.channel.send(msg)
        
    @commands.command()
    async def newticket(self, ctx):
        """Initiate a new-ticket conversation with the bot. The ticket will be added to the bottom of the queue"""
        
        enabled = self.settings.getServerStat(ctx.guild, "UseTickets")
        
        # If Tickets aren't enabled,
        
        if not enabled:
            msg = 'Tickets aren\'t enabled for this server. Admins can enable tickets with {}allowtickets [yes/no]'.format(ctx.prefix)
            return await ctx.send(msg)
        
        queue = self.settings.getServerStat(ctx.guild, "")
        
        server = ctx.message.guild.id
        
        ticketChannel = None
        if ctx.guild:
            # Not a pm
            ticketChannel = self.settings.getServerStat(ctx.guild, "TicketsChannel")
            if not (not ticketChannel or ticketChannel == ""):
                # Need channel ID
                if not str(ticketChannel) == str(ctx.channel.id):
                    msg = 'This isn\'t the channel for that...'
                    for chan in ctx.guild.channels:
                        if str(chan.id) == str(ticketChannel):
                            msg = 'This isn\'t the channel for that. Please use the **{}** channel for tickets.'.format(chan.name)
                        return await ctx.send(msg)
                else:
                    ticketChannel = self.bot.get_channel(ticketChannel)
        if not ticketChannel:
            # No channel set - use PM
            ticketChannel = ctx.author
            
        # Ensure not in ticket session already
        if str(ctx.author.id) in self.ticketactive:
            return await ctx.send("You're already in a ticket session! You can leave with `{}cancelticket`".format(ctx.prefix))
            
        # Set TicketActive flag
        ticket_id = self.gen_id()
        self.ticketactive[str(ctx.author.id)] = ticket_id
        
        msg = 'Alright, *{}*, let\'s make a new ticket.\n\n'.format(DisplayName.name(ctx.author))
        
        # handle too many tickets in queue
        if len(self.tickets) >= self.ticketMax:
            return await ctx.send('Sorry, there are too many tickets in the queue. Please try again later.\n\n')
            
        try:
            await ticketChannel.send(msg)
        except:
            # Can't send message to destination
            self._stop_ticket(ctx.author)
            if ticketChannel == ctx.author:
                # Must not allow PMs
                await ctx.send("It looks like you don't accept PMs. Please enable them and try again.")
            return
        
        if ticketChannel == ctx.author and ctx.channel != ctx.author.dm_channel:
            await ctx.message.add_reaction("ðŸ“¬")
        msg = '*{}*, What should the subject of the ticket be? Be concise but descriptive.\n\nFor example, "Error code 0xc0000001 on boot" is a more descriptive subject than "My PC won\'t start".\n\n(type stop to cancel):'.format(DisplayName.name(ctx.author))
        
        # Get the ticket name
        newTicket = {}
        
        while True:
            ticketName = await self.prompt(ticket_id, ctx, msg, ticketChannel, DisplayName.name(ctx.author))
            
        
        for x in qs:
            if x['serverID'] == server:
                return
                
        await ctx.send(self.queues['serverID']['ticketNum'])
        
    
    async def prompt(self, ticket_id, ctx, message, dest = None, author = None):
        # Get author name
        authorName = None
        if author:
            if type(author) is str:
                authorName = author
            else:
                try:
                    authorName = DisplayName.name(author)
                except Exception:
                    pass
        else:
            if message:
                try:
                    author = message.author
                except Exception:
                    pass
            try:
                authorName = DisplayName.name(message.author)
            except Exception:
                pass

        if not dest:
            dest = ctx.channel
        if self.checkSuppress(ctx):
            msg = Nullify.clean(message)
        await dest.send(message)
        while True:
            def littleCheck(m):
                return ctx.author.id == m.author.id and self.channelCheck(m, dest) and len(m.content)
            try:
                talk = await self.bot.wait_for('message', check=littleCheck, timeout=300)
            except Exception:
                talk = None

            # See if we're still in the right context
            if not ticket_id == self.ticketactive.get(str(ctx.author.id),None):
                return None

            # Hardware ended
            if not self.stillTicketing(ctx.author):
                return None

            if not talk:
                msg = "*{}*, I'm out of time...".format(authorName)
                await dest.send(msg)
                return None
            else:
                # Check for a stop
                if talk.content.lower() == 'stop':
                    msg = "No problem, *{}!*  See you later!".format(authorName, ctx.prefix)
                    await dest.send(msg)
                    return None
                # Make sure
                conf = await self.confirm(ticket_id, ctx, talk, dest, "", author)
                if conf == True:
                    # We're sure - return the value
                    return talk
                elif conf == False:
                    # Not sure - ask again
                    return await self.prompt(ticket_id, ctx, message, dest, author)
                else:
                    # Timed out
                    return None
                    
    # Makes sure we're still editing - if this gets set to False,
    # that means the user stopped editing/newhw
    def stillTicketing(self, author):
        return str(author.id) in self.ticketactive
    
    # def _stop_ticket()
    
    #def ticket_timeout()
    
    


"""        
    @commands.command()
    async def tickets():
        
        
    @commands.command()
    async def closeticket():
        return
"""